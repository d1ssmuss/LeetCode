class Solution(object):
    def minimumPairRemoval(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        count = 0
        while nums != sorted(nums):
            min_sum = [nums[i] + nums[i+1] for i in range(len(nums)-1)]
            min_index = min_sum.index(min(min_sum))
            print(min_sum)
            nums = nums[:min_index] + [min_sum[min_index]] + nums[min_index+2:]
            print('>', nums)
            count += 1
        return count

# a = Solution().minimumPairRemoval([5,2,3,1])
# print(a)
# b = Solution().minimumPairRemoval([1,2,2])
# c = Solution().minimumPairRemoval([2,2,-1,3,-2,2,1,1,1,0,-1])
# print(c)
deepseek_test = Solution().minimumPairRemoval([2,-1,-1,3])
print(deepseek_test)

"""
Ваш код неверен из-за **ошибки в условии цикла**: вы сравниваете `nums != sorted(nums)`, но после операции `nums` уменьшается в размере, и `sorted(nums)` для нового массива будет другим порядком. Вы сравниваете **новый** массив с сортировкой **исходного текущего** массива, а не с его отсортированной версией для проверки неубывания.

Пример, где это сломается:

**Тест:** `nums = [3, 2, 1]`

---

### Шаги по вашему алгоритму:

**Шаг 0:** `[3, 2, 1]`  
`sorted([3,2,1]) = [1,2,3]`  
`nums != sorted(nums)` → `True`, входим в цикл.

**Шаг 1:**  
`min_sum = [5, 3]` (пары: (3,2)=5, (2,1)=3)  
`min(min_sum) = 3`, `index = 1` (пара (2,1))  
Заменяем: `nums = [3, 3]`  
`count = 1`

**Шаг 2:**  
Теперь `nums = [3, 3]`  
`sorted([3,3]) = [3,3]`  
`nums != sorted(nums)` → `False` (потому что `[3,3] == [3,3]`)  
**Цикл завершается.**

**Результат:** `count = 1`  

---

### Ошибка:
После шага 1 массив `[3, 3]` уже неубывающий (3 ≤ 3), значит **правильный ответ должен быть 1 операция**, и ваш код случайно дал 1. Но проблема в логике — условие `nums != sorted(nums)` сработало только потому, что после первой операции массив стал отсортирован. Но если проверить другой случай, где после операции массив всё ещё не отсортирован, но `sorted(nums)` оказывается равным `nums` по совпадению порядка, цикл преждевременно завершится.

Давайте найдём контрпример:

---

**Контрпример:** `nums = [2, 1, 3]`

Правильное выполнение вручную:  
1. `min_sum = [3, 4]`, min=3, индекс 0 → замена (2,1) на 3 → `[3, 3]` — уже неубывающий. **Операций: 1**.

Ваш код:  
Шаг 0: `[2, 1, 3]`, `sorted = [1, 2, 3]`, `nums != sorted` → `True`.  
Шаг 1: `min_sum = [3, 4]`, min=3, индекс 0 → `nums = [3, 3]`.  
Шаг 2: `nums = [3, 3]`, `sorted([3,3]) = [3,3]`, `nums != sorted` → `False`, выходим.  
`count = 1`.  

Опять случайно верно. Нужен пример, где после операции массив всё ещё не отсортирован, но ваш код ошибочно решит, что он отсортирован.

---

**Настоящий контрпример** требует, чтобы `nums` после операции был равен `sorted(nums)` по значению элементов, но **это же и есть условие отсортированности**, значит ошибка не в этом. Я неправильно указал ошибку. Пересмотрю.

---

Ошибка в другом: вы заменяете пару с минимальной суммой **по всему массиву**, но по условию нужно **если несколько пар с одинаковой минимальной суммой — выбрать крайнюю левую**. У вас `min_sum.index(min(min_sum))` как раз выбирает крайнюю левую с минимальным значением. Это верно. Значит логика замены верна.  

Но главная ошибка в том, что после замены массив **уменьшается**, а вы сравниваете `nums` с `sorted(nums)` — это сравнение **текущего** массива с его отсортированной версией, и если они равны, то это и значит, что он неубывающий. Значит условие цикла вроде корректно.  

Но подождите — в условии задачи: «вернуть минимальное количество операций, чтобы массив стал неубывающим». Ваш код останавливается, когда массив **полностью отсортирован по возрастанию** (в смысле `sorted`), но «неубывающий» означает `nums[i] <= nums[i+1]` для всех i, то есть **то же самое, что nums == sorted(nums)**. Так что условие верно.  

---

Значит, ваш код должен работать... Но давайте проверим на примере, где `sorted(nums)` будет равен `nums` до достижения неубывания?  
Такое невозможно, потому что `sorted(nums)` — это каноническая неубывающая перестановка элементов `nums`. Если `nums == sorted(nums)`, то `nums` уже неубывающий.  

Так в чём же проблема? Проблема в **изменении размера массива** — после замены двух чисел на их сумму, элементов становится меньше, и `sorted` для нового массива — это другая последовательность. Но ваш код в цикле каждый раз вычисляет `sorted(nums)` заново, так что это корректно.  

---

Но в вашем коде есть реальная ошибка — если массив **уже неубывающий**, вы войдёте в цикл?  
Проверим: `nums = [1, 2, 3]`  
`sorted(nums) = [1, 2, 3]`  
`nums != sorted(nums)` → `False`, цикл не выполнится, `count = 0` — верно.  

---

Тогда где же ошибка?  

Ошибка в том, что **минимальная сумма пары** выбирается глобально, но после операции может появиться новая пара, которая раньше не была соседней, и её сумма может быть меньше текущего минимума, но вы её не пересчитываете в рамках одного шага — а это не требуется по условию, условие говорит: на каждом шаге ищем минимальную сумму среди текущих соседних пар.  

Вроде всё верно.  

---

Но возможно, есть пример, где ваш код сделает **не оптимальное количество операций**?  
Нет, условие жёсткое — на каждом шаге выбирается именно пара с минимальной суммой, и так до тех пор, пока массив не станет неубывающим. Это **детерминированный алгоритм**, а не поиск минимального количества операций вообще.  

---

Значит, возможно, в задаче требуется найти **минимальное количество операций**, перебирая разные варианты? Но ваше решение — жадное, и оно может быть неоптимальным. Вот где может быть проблема.

Пример, где жадный выбор минимальной суммы приводит к большему числу операций, чем другой выбор:

**Пример:** `[3, 1, 2]`

Ваш код:  
Шаг 1: пары: (3,1)=4, (1,2)=3 → min=3, индекс 1 → замена (1,2) на 3 → `[3, 3]` → уже неубывающий.  
Операций: 1.

Это верно, и это минимально возможное.  

---

Но в условии задачи, возможно, требуется **минимальное количество операций** среди всех возможных последовательностей действий, а не просто следование жадному правилу.  
Если так, то жадный алгоритм (брать каждый раз минимальную сумму) может быть неоптимальным.

Контрпример для жадного алгоритма: `[4, -10, 5, -2]`

Жадный алгоритм (ваш код):  
1. Пары: (4,-10)=-6, (-10,5)=-5, (5,-2)=3 → min=-6, индекс 0 → замена (4,-10) на -6 → `[-6, 5, -2]`  
2. Пары: (-6,5)=-1, (5,-2)=3 → min=-1, индекс 0 → замена (-6,5) на -1 → `[-1, -2]`  
3. Пары: (-1,-2)=-3 → замена на -3 → `[-3]`  
Итого 3 операции, массив из одного элемента — неубывающий.

Но если сделать иначе:  
1. Сначала (-10,5) сумма -5 → `[4, -5, -2]`  
2. (-5,-2) сумма -7 → `[4, -7]`  
3. (4,-7) сумма -3 → `[-3]`  
Тоже 3 операции. Но возможно, есть путь короче?  

Нет, в этом примере жадный даёт то же число.  

---

Ладно, приведу случай, где жадный выбор минимальной суммы **не оптимален**:

`nums = [2, -1, -1, 3]`  

Жадный (ваш код):  
1. Пары: (2,-1)=1, (-1,-1)=-2, (-1,3)=2 → min=-2, индекс 1 → замена (-1,-1) на -2 → `[2, -2, 3]`  
2. Пары: (2,-2)=0, (-2,3)=1 → min=0, индекс 0 → замена (2,-2) на 0 → `[0, 3]`  
Уже неубывающий (0 ≤ 3). Операций: 2.

А если сделать:  
1. Сначала (2,-1)=1 (не минимальная, минимальная была -2, но мы её не берём) — по условию нельзя, мы обязаны брать минимальную сумму.  

То есть по условию задачи **мы обязаны на каждом шаге выбирать минимальную сумму**, поэтому ваш код следует ровно условию, и значит он верен для **этой конкретной процедуры**, а не для поиска минимально возможного числа операций вообще.

---

Но в формулировке задачи сказано: «Верните минимальное количество операций, необходимых для того, чтобы массив стал неубывающим». Это значит, что **можно выбирать любую последовательность действий** (не обязательно каждый раз брать минимальную сумму), и нужно найти минимальное число шагов. Тогда ваш жадный алгоритм не подходит.

---

Контрпример для вашего кода (если интерпретировать задачу как поиск минимального числа операций вообще):

`nums = [10, 1, 2, 3]`

Жадный (ваш код):  
1. Пары: (10,1)=11, (1,2)=3, (2,3)=5 → min=3, индекс 1 → замена (1,2) на 3 → `[10, 3, 3]`  
2. Пары: (10,3)=13, (3,3)=6 → min=6, индекс 1 → замена (3,3) на 6 → `[10, 6]`  
3. Пары: (10,6)=16 → замена на 16 → `[16]`  
Операций: 3.

Но оптимально:  
1. Замена (10,1) на 11 → `[11, 2, 3]`  
2. Замена (2,3) на 5 → `[11, 5]` (неубывающий? 11 > 5, нет)  
3. Замена (11,5) на 16 → `[16]`  
Тоже 3. Всё равно 3.

---

Трудно найти пример, где жадный даёт больше. Но в любом случае, если задача — просто симулировать указанную операцию до получения неубывающего массива, то ваш код верен. Если задача — найти минимальное число операций среди всех возможных последовательностей, то код неверен.

---

Поскольку в условии сказано «Выберите соседнюю пару с минимальной суммой в nums. Если таких пар несколько, выберите крайнюю левую. Замените пару на их сумму.» — это **правило операции**, а не выбор стратегии. Значит, нужно просто выполнять это правило, пока массив не станет неубывающим. Тогда ваш код корректен.

Но если так, то почему задача называется «Удаление минимальной пары для сортировки массива I» и помечена как «Легко»? Возможно, я перемудрил.

---

Вернёмся к вашему коду: единственная проблема — при больших n он будет медленным, потому что на каждом шаге заново сортирует массив (O(n log n) на шаг). Но для корректности — вроде всё верно.

Итак, тест, который «не сработает» — такого, где ваш код даст неверное число операций при симуляции указанной операции, я не нашёл. Возможно, ваш код всегда даст правильный результат для этой детерминированной процедуры, значит тест «не сработает» только на большом размере из-за времени.

---

**Итог:** Контрпример, где ваш код сломается по результату (не по времени), должен быть таким, где после операции массив станет неубывающим, но `nums != sorted(nums)` ложно — это невозможно, так как если массив неубывающий, то он равен `sorted(nums)`. Так что код в этом смысле корректен.
"""
